{"mappings":"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","sources":["./front/i18nText.ts","./front/index.ts"],"sourcesContent":["export default {\n  me: {\n    ja: \"私\",\n    en: \"me\",\n    zh: \"我\"\n  },\n  you: {\n    ja: \"あなた\",\n    en: \"you\",\n    zh: \"你\"\n  }\n}\n","/*\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.\n    If not, see <https://www.gnu.org/licenses/agpl-3.0.en.html>.\n*/\n\n\"use strict\"\n\nimport i18nText from \"./i18nText\"\n\n// system const\nconst FRAME_RATE = 60\nconst GAME_SET_CHAIN_SIZE = 5\nconst COMBO_SIZE = 3\nconst DEFAULT_COUNTRY = \"ja\"\n\n// ui const\nconst TOKEN_SIZE = 60\nconst WEIGHT_BOLD = 5\nconst WEIGHT_DEFAULT = 1\nconst COLOR_BASE = 50\nconst COLOR_MAIN = 245\nconst COLOR_FIRST_LASER = 0\nconst COLOR_SECOND_LASER = 200\nconst COLOR_FIRST = `hsl(0, 75%, 65%)`\nconst COLOR_SECOND = `hsl(180, 75%, 65%)`\nconst COLOR_FOCUS_FIELD = `rgba(${COLOR_MAIN}, ${COLOR_MAIN}, ${COLOR_MAIN}, 0.05)`\nconst TEXT_FONT = \"Ranchers\"\nconst MARGIN_FIRLD = TOKEN_SIZE\nconst COMBO_ANIME_DELAY = 10\n\nenum Player {\n  First,\n  Second,\n}\n\nenum GameState {\n  Play,\n  GameSet,\n}\n\nenum GameStateEvent {\n  Init,\n  Play,\n  GameSet,\n}\n\nenum AnimeEvent {\n  Play,\n  Done,\n  Abort,\n}\n\nenum TurnEvent {\n  ToggleField,\n  ToggleTurn,\n}\n\n// ---------------------------------------------------\n// Definition of classes & functions used in the game.\n// ---------------------------------------------------\n\nclass I18n {\n  i18nText: { [key: string]: { [key: string]: string } } = i18nText\n  country: string\n\n  constructor() {\n    this.setCountry()\n  }\n\n  setCountry(country?: string): void {\n    if (country) {\n      this.country = country\n      return\n    }\n\n    country = window.navigator.language\n    if (country && country !== \"\") {\n      this.country = country.slice(0, 2)\n      return\n    }\n\n    this.country = DEFAULT_COUNTRY\n  }\n\n  get(keyword: string): string {\n    let countries = i18nText[keyword]\n    if (countries === undefined) {\n      never(`i18n keyword is undefined. keyword: ${keyword}`)\n    }\n    return countries[this.country] ?? countries[DEFAULT_COUNTRY]\n  }\n}\n\nclass Delayer {\n  callbacks: Map<number, Array<() => void>> = new Map()\n\n  set(delay: number, callback: () => void): void {\n    let list = this.callbacks.get(frameCount + delay) ?? []\n    list.push(callback)\n    this.callbacks.set(frameCount + delay, list)\n  }\n\n  nextFrame(callback: () => void): void {\n    this.set(1, callback)\n  }\n\n  check(): void {\n    let list = this.callbacks.get(frameCount)\n    if (list === undefined) {\n      return\n    }\n\n    for (let callback of list) {\n      callback()\n    }\n    this.callbacks.delete(frameCount)\n  }\n}\n\nclass EventEmitter<T> {\n  listeners: Map<T, Function[]> = new Map()\n  onceListeners: Map<T, Function[]> = new Map()\n\n  on(eventName: T, listener: Function) {\n    let list = this.listeners.get(eventName) ?? []\n    list.push(listener)\n    this.listeners.set(eventName, list)\n  }\n\n  onOnce(eventName: T, listener: Function): void {\n    let list = this.onceListeners.get(eventName) ?? []\n    list.push(listener)\n    this.onceListeners.set(eventName, list)\n  }\n\n  emit(eventName: T, ...args: any[]): void {\n    let list = this.listeners.get(eventName) ?? []\n    for (let listener of list) {\n      listener(...args)\n    }\n\n    list = this.onceListeners.get(eventName) ?? []\n    for (let listener of list) {\n      listener(...args)\n    }\n    this.onceListeners.delete(eventName)\n  }\n}\n\ninterface AudioElements {\n  token: HTMLAudioElement | undefined\n  laser: HTMLAudioElement | undefined\n  gameset: HTMLAudioElement | undefined\n  blink: HTMLAudioElement | undefined\n}\nclass Sound {\n  audioElements: AudioElements\n\n  setup() {\n    this.audioElements = {\n      token: this.setupAudioElement(\"token\"),\n      laser: this.setupAudioElement(\"laser\"),\n      gameset: this.setupAudioElement(\"gameset\"),\n      blink: this.setupAudioElement(\"blink\"),\n    }\n  }\n\n  play(name: keyof AudioElements): void {\n    let a = this.audioElements[name] ?? never()\n    if (a.readyState === HTMLMediaElement.HAVE_ENOUGH_DATA) {\n      a.currentTime = 0\n      a.play()\n    }\n  }\n\n  stop(name: keyof AudioElements): void {\n    let a = this.audioElements[name] ?? never()\n    if (a.readyState === HTMLMediaElement.HAVE_ENOUGH_DATA) {\n      a.pause()\n    }\n  }\n\n  private setupAudioElement(name: string): HTMLAudioElement {\n    let e = document.getElementById(`audio-${name}`) ?? never()\n\n    if (e instanceof HTMLAudioElement) {\n      return e\n    } else {\n      never()\n    }\n  }\n}\n\ntype AnimeHandler = (\n  frame: number,\n  params: { [key: string]: any }\n) => boolean | void\nclass Anime extends EventEmitter<AnimeEvent> {\n  handler: AnimeHandler\n  isPlay: boolean\n  startFrameCount: number\n  params: { [key: string]: any }\n\n  // The callback will be called when all animations are done.\n  static doneAll(animes: Anime[], callback: () => void): void {\n    const maxCount = animes.length\n    let count = 0\n\n    animes.forEach((a) => {\n      a.onOnce(AnimeEvent.Done, () => {\n        count += 1\n        if (maxCount <= count) {\n          callback()\n        }\n      })\n    })\n  }\n\n  static playParallel(animes: Anime[], delay: number): Anime {\n    if (animes.length === 0) {\n      never('\"animes\" should be one or more arrays')\n    } else if (animes.length <= 1) {\n      return head(animes).play()\n    } else {\n      head(animes).play()\n      delayer.set(delay, () => {\n        this.playParallel(rest(animes), delay)\n      })\n      return tail(animes)\n    }\n  }\n\n  constructor(\n    handler: (frame: number, params?: { [key: string]: any }) => boolean | void,\n    params?: object\n  ) {\n    super()\n    this.handler = handler\n    this.params = params ?? {}\n    this.init()\n  }\n\n  play(): Anime {\n    this.isPlay = true\n    this.startFrameCount = frameCount\n    this.emit(AnimeEvent.Play)\n    return this\n  }\n\n  abort(): Anime {\n    this.init\n    this.emit(AnimeEvent.Abort)\n    return this\n  }\n\n  draw() {\n    if (!this.isPlay) {\n      return\n    }\n\n    let isEnd = this.handler(frameCount - this.startFrameCount, this.params)\n    if (isEnd) {\n      this.init()\n      this.emit(AnimeEvent.Done, this)\n    }\n  }\n\n  private init() {\n    this.isPlay = false\n    this.startFrameCount = 0\n  }\n}\n\nclass AnimeViews {\n  animes: Set<Anime> = new Set()\n\n  add(anime: Anime): void {\n    this.animes.add(anime)\n\n    anime.onOnce(AnimeEvent.Done, () => {\n      this.animes.delete(anime)\n    })\n    anime.onOnce(AnimeEvent.Abort, () => {\n      this.animes.delete(anime)\n    })\n  }\n\n  draw() {\n    for (let a of this.animes) {\n      a.draw()\n    }\n  }\n}\n\nclass Scroller {\n  x: number = 0\n  y: number = 0\n  private startX: number = 0\n  private startY: number = 0\n  private oldX: number = 0\n  private oldY: number = 0\n\n  init() {\n    this.x = 0\n    this.y = 0\n    this.startX = 0\n    this.startY = 0\n    this.oldX = 0\n    this.oldY = 0\n  }\n\n  touchStarted() {\n    this.startX = mouseX\n    this.startY = mouseY\n    this.oldX = this.x\n    this.oldY = this.y\n  }\n\n  touchMoved() {\n    cursor(\"grabbing\")\n    this.x = this.oldX + mouseX - this.startX\n    this.y = this.oldY + mouseY - this.startY\n  }\n\n  touchEnded() {\n    cursor(\"auto\")\n  }\n}\n\ntype Token = FirstToken | SecondToken | GuideToken\n\nabstract class AbstractToken {\n  x: number\n  y: number\n\n  abstract draw(): void\n\n  get baseX(): number {\n    return this.x - scroller.x\n  }\n\n  get baseY(): number {\n    return this.y - scroller.y\n  }\n\n  get centerX(): number {\n    return this.baseX + TOKEN_SIZE / 2\n  }\n\n  get centerY(): number {\n    return this.baseY + TOKEN_SIZE / 2\n  }\n}\n\nabstract class PlayerToken extends AbstractToken {\n  x: number\n  y: number\n  readonly player: Player\n  blinkAnime: Anime\n  color: string\n\n  constructor() {\n    super()\n    let max = 10\n    this.blinkAnime = new Anime((frame: number) => {\n      if (frame === 1) {\n        sound.play(\"blink\")\n      }\n      stroke(255)\n      strokeWeight((30 * frame) / max)\n      fill(this.color)\n      rect(this.x, this.y, TOKEN_SIZE, TOKEN_SIZE)\n\n      if (max <= frame) {\n        sound.stop(\"blink\")\n        return true\n      }\n    })\n  }\n\n  draw() {\n    if (this.blinkAnime.isPlay) {\n      this.blinkAnime.draw()\n    } else {\n      stroke(COLOR_MAIN)\n      strokeWeight(WEIGHT_DEFAULT)\n      fill(this.color)\n      rect(this.x, this.y, TOKEN_SIZE, TOKEN_SIZE)\n    }\n  }\n}\n\nclass FirstToken extends PlayerToken {\n  readonly player = Player.First\n  color = COLOR_FIRST\n}\n\nclass SecondToken extends PlayerToken {\n  readonly player = Player.Second\n  color = COLOR_SECOND\n}\n\nclass GuideToken extends AbstractToken {\n  readonly player = undefined\n  anime: Anime\n\n  constructor() {\n    super()\n    const ALPHA_BASE = 20\n    const PHASE = [150, 250, 400]\n    this.anime = new Anime((frame: number) => {\n      frame = frame % PHASE[PHASE.length - 1]\n\n      let c = color(\n        turnModerator.player === Player.First ? COLOR_FIRST : COLOR_SECOND\n      )\n      if (frame <= PHASE[0]) {\n        let max = PHASE[0]\n        let strength = (max - frame) / max\n        c.setAlpha(255 * 0.3 * strength + ALPHA_BASE)\n      } else if (frame <= PHASE[1]) {\n        c.setAlpha(ALPHA_BASE)\n      } else {\n        let min = PHASE[1]\n        let max = PHASE[2]\n        let strength = (frame - min) / (max - min)\n        c.setAlpha(255 * 0.3 * strength + ALPHA_BASE)\n      }\n\n      fill(c)\n      noStroke()\n      rect(this.x, this.y, TOKEN_SIZE, TOKEN_SIZE)\n    })\n  }\n\n  play(): Anime {\n    return this.anime.play()\n  }\n\n  abort(): Anime {\n    return this.anime.abort()\n  }\n\n  draw() {\n    this.anime.draw()\n  }\n}\n\nfunction makeTokenTurn(): Token {\n  switch (turnModerator.player) {\n    case Player.First:\n      return new FirstToken()\n    case Player.Second:\n      return new SecondToken()\n    default:\n      return never()\n  }\n}\n\nclass FieldData {\n  data: Array<Array<Token> | undefined>\n\n  constructor() {\n    this.init()\n  }\n\n  init() {\n    this.data = [[new GuideToken()]]\n  }\n\n  set(token: Token, column: number, row: number): void {\n    if (column < 0) {\n      return\n    }\n    if (row < 0) {\n      return\n    }\n\n    if (this.data[column] === undefined) {\n      this.data[column] = []\n    }\n    // @ts-ignore\n    this.data[column][row] = token\n  }\n\n  // Add only if empty.\n  add(token: Token, column: number, row: number): void {\n    if (undefined === this.get(column, row)) {\n      this.set(token, column, row)\n    }\n  }\n\n  get(column: number, row: number): Token | undefined {\n    if (column < 0) {\n      return undefined\n    }\n    if (row < 0) {\n      return undefined\n    }\n\n    let a = this.data[column] ?? []\n    return a[row]\n  }\n\n  forEach(callback: Function) {\n    this.data.forEach((v, column) => {\n      if (v === undefined) {\n        return\n      }\n      v.forEach((token, row) => {\n        callback(token, column, row)\n      })\n    })\n  }\n\n  getComboLines(\n    column: number,\n    row: number,\n    size: number\n  ): Array<Array<Token | undefined>> {\n    const lines: Array<Array<Token | undefined>> = []\n    let tokenLine: Array<Token | undefined> = []\n    size -= 1\n\n    // direction : horizontal\n    tokenLine = range(-size, size).map((offset) =>\n      this.get(column + offset, row)\n    )\n    lines.push(tokenLine)\n\n    // direction : virtical\n    tokenLine = range(-size, size).map((offset) =>\n      this.get(column, row + offset)\n    )\n    lines.push(tokenLine)\n\n    // direction : down and left\n    tokenLine = range(-size, size).map((offset) =>\n      this.get(column + offset, row + offset)\n    )\n    lines.push(tokenLine)\n\n    // direction : down and right\n    tokenLine = range(-size, size).map((offset) =>\n      this.get(column - offset, row + offset)\n    )\n    lines.push(tokenLine)\n\n    return lines\n  }\n}\n\nabstract class AbstractField extends EventEmitter<GameStateEvent> {\n  fieldData: FieldData\n  player: Player\n  baseX: number\n  baseY: number\n  enable: boolean\n\n  abstract draw(): void\n\n  // convert x, y -> column, row\n  abstract toCell(column: number, row: number): { column: number; row: number }\n\n  abstract windowResized(): void\n\n  constructor() {\n    super()\n    this.windowResized()\n    this.fieldData = new FieldData()\n  }\n\n  get x() {\n    return this.baseX + scroller.x\n  }\n\n  get y() {\n    return this.baseY + scroller.y\n  }\n\n  add(token: Token, column: number, row: number): void {\n    if (turnModerator.canPutField !== this.player) {\n      return\n    }\n\n    this.fieldData.set(token, column, row)\n    let tokens = judgeGameSet(turnModerator.player, column, row, this.fieldData)\n    if (0 < tokens.length) {\n      this.emit(GameStateEvent.GameSet, tokens)\n      return\n    }\n\n    this.addCandidates(column, row)\n\n    delayer.nextFrame(() => {\n      let combos = getCombos(turnModerator.player, column, row, this.fieldData)\n      chainComboAnimate(combos)\n      turnModerator.addComboCount(combos.length)\n      turnModerator.action()\n      this.guideAnimePlay()\n      sound.play(\"token\")\n    })\n  }\n\n  private addCandidates(column: number, row: number): void {\n    this.fieldData.add(new GuideToken(), column + 1, row)\n    this.fieldData.add(new GuideToken(), column - 1, row)\n    this.fieldData.add(new GuideToken(), column, row + 1)\n    this.fieldData.add(new GuideToken(), column, row - 1)\n  }\n\n  private guideAnimePlay() {\n    this.fieldData.forEach((token: Token) => {\n      if (token instanceof GuideToken) {\n        token.play()\n      }\n    })\n  }\n\n  init() {\n    this.fieldData.init()\n    this.enable = true\n    this.guideAnimePlay()\n  }\n\n  mouseClicked() {\n    const { column, row } = this.toCell(mouseX, mouseY)\n    if (column < 0) {\n      return\n    }\n    if (row < 0) {\n      return\n    }\n\n    let token = this.fieldData.get(column, row)\n    if (token instanceof GuideToken) {\n      this.add(makeTokenTurn(), column, row)\n      return false\n    }\n  }\n}\n\n// The field you can see on the left.\nclass FirstField extends AbstractField {\n  constructor() {\n    super()\n    this.player = Player.First\n  }\n\n  toCell(x: number, y: number): { column: number; row: number } {\n    return {\n      column: floor((this.x - x) / TOKEN_SIZE),\n      row: floor((this.y - y) / TOKEN_SIZE),\n    }\n  }\n\n  draw() {\n    if (!this.enable) {\n      return\n    }\n\n    // background\n    if (turnModerator.canPutField === this.player) {\n      fill(COLOR_FOCUS_FIELD)\n      noStroke()\n      rect(0, 0, this.x, this.y)\n    }\n\n    // line\n    let isCanPutField = turnModerator.canPutField === this.player\n    if (isCanPutField) {\n      strokeWeight(WEIGHT_BOLD)\n      if (turnModerator.player === Player.First) {\n        stroke(COLOR_FIRST)\n      } else {\n        stroke(COLOR_SECOND)\n      }\n    } else {\n      strokeWeight(WEIGHT_DEFAULT)\n      stroke(COLOR_MAIN)\n    }\n    line(this.x, this.y, this.x, 0)\n    line(this.x, this.y, 0, this.y)\n\n    // tokens\n    strokeWeight(WEIGHT_DEFAULT)\n    stroke(COLOR_MAIN)\n    this.fieldData.forEach(\n      (token: Token | undefined, column: number, row: number) => {\n        if (token === undefined) {\n          return\n        }\n        if (token instanceof GuideToken && !isCanPutField) {\n          return\n        }\n        token.x = this.x - (column + 1) * TOKEN_SIZE\n        token.y = this.y - (row + 1) * TOKEN_SIZE\n        token.draw()\n      }\n    )\n  }\n\n  windowResized() {\n    this.baseX = windowWidth / 2 - MARGIN_FIRLD / 2\n    this.baseY = windowHeight - MARGIN_FIRLD\n  }\n}\n\n// The field you can see on the right.\nclass SecondField extends AbstractField {\n  constructor() {\n    super()\n    this.player = Player.Second\n  }\n\n  toCell(x: number, y: number): { column: number; row: number } {\n    return {\n      column: floor((x - this.x) / TOKEN_SIZE),\n      row: floor((this.y - y) / TOKEN_SIZE),\n    }\n  }\n\n  draw() {\n    if (!this.enable) {\n      return\n    }\n\n    // background\n    if (turnModerator.canPutField === this.player) {\n      fill(COLOR_FOCUS_FIELD)\n      noStroke()\n      rect(this.x, 0, windowWidth - scroller.x, this.y)\n    }\n\n    // line\n    let isCanPutField = turnModerator.canPutField === this.player\n    if (isCanPutField) {\n      strokeWeight(WEIGHT_BOLD)\n      if (turnModerator.player === Player.First) {\n        stroke(COLOR_FIRST)\n      } else {\n        stroke(COLOR_SECOND)\n      }\n    } else {\n      strokeWeight(WEIGHT_DEFAULT)\n      stroke(COLOR_MAIN)\n    }\n    line(this.x, this.y, this.x, 0)\n    line(this.x, this.y, windowWidth, this.y)\n\n    // tokens\n    strokeWeight(WEIGHT_DEFAULT)\n    stroke(COLOR_MAIN)\n    this.fieldData.forEach(\n      (token: Token | undefined, column: number, row: number) => {\n        if (token === undefined) {\n          return\n        }\n        if (token instanceof GuideToken && !isCanPutField) {\n          return\n        }\n        token.x = this.x + column * TOKEN_SIZE\n        token.y = this.y - (row + 1) * TOKEN_SIZE\n        token.draw()\n      }\n    )\n  }\n\n  windowResized() {\n    this.baseX = windowWidth / 2 + MARGIN_FIRLD / 2\n    this.baseY = windowHeight - MARGIN_FIRLD\n  }\n}\n\nclass GameSetScene extends EventEmitter<GameStateEvent> {\n  private enable: boolean\n  private player: Player | undefined\n\n  private showAnime: Anime = new Anime((frame) => {\n    this.coreDraw(frame / 30)\n\n    if (30 <= frame) {\n      return true\n    }\n  })\n\n  private hideAnime: Anime = new Anime((frame) => {\n    this.coreDraw(1)\n\n    let strength = frame / 20\n    strength = easeInOutQuad(strength)\n\n    fill(COLOR_BASE)\n    rect(0, 0, (windowWidth / 2) * strength, windowHeight)\n    rect(\n      windowWidth - (windowWidth / 2) * strength,\n      0,\n      windowWidth,\n      windowHeight\n    )\n\n    if (20 <= frame) {\n      return true\n    }\n  })\n\n  constructor() {\n    super()\n    this.init()\n  }\n\n  init() {\n    this.enable = false\n    this.player = undefined\n  }\n\n  show(player: Player) {\n    this.enable = true\n    this.player = player\n    this.showAnime.play()\n  }\n\n  hide() {\n    this.hideAnime.onOnce(AnimeEvent.Done, () => {\n      this.enable = false\n      this.player = undefined\n      this.emit(GameStateEvent.Init)\n    })\n\n    this.hideAnime.play()\n  }\n\n  mouseClicked() {\n    if (!this.enable) {\n      return\n    }\n    this.hide()\n    return false\n  }\n\n  draw() {\n    if (!this.enable) {\n      return\n    }\n\n    if (this.showAnime.isPlay) {\n      this.showAnime.draw()\n    } else if (this.hideAnime.isPlay) {\n      this.hideAnime.draw()\n    } else {\n      this.coreDraw(1)\n    }\n  }\n\n  coreDraw(alphaRate: number) {\n    let size = getTextSize()\n\n    background(COLOR_MAIN)\n    textSize(size)\n\n    noStroke()\n    let c = color(COLOR_BASE)\n    c.setAlpha(255 * alphaRate)\n    fill(c)\n    text(\"Game Set\", windowWidth / 2, windowHeight / 2 - size)\n\n    stroke(c)\n    strokeWeight(8)\n    if (this.player == Player.First) {\n      c = color(COLOR_FIRST)\n      c.setAlpha(255 * alphaRate)\n      fill(c)\n      text(`Win : Red`, windowWidth / 2, windowHeight / 2 + size)\n    } else {\n      c = color(COLOR_SECOND)\n      c.setAlpha(255 * alphaRate)\n      fill(c)\n      text(`Win : Blue`, windowWidth / 2, windowHeight / 2 + size)\n    }\n  }\n}\n\nclass TurnModerator extends EventEmitter<TurnEvent> {\n  player: Player\n  actionCount: number\n  canPutField: Player\n\n  constructor() {\n    super()\n    this.init()\n  }\n\n  init() {\n    this.player = Player.First\n    this.actionCount = 1\n    this.canPutField = Player.First\n  }\n\n  action() {\n    this.actionCount -= 1\n    if (this.actionCount <= 0) {\n      this.toggleTurn()\n    }\n  }\n\n  addComboCount(count: number) {\n    if (count === 0) {\n      return\n    }\n    this.actionCount += count\n    this.toggleField()\n  }\n\n  toggleField() {\n    this.canPutField =\n      this.canPutField === Player.First ? Player.Second : Player.First\n    this.emit(TurnEvent.ToggleField)\n  }\n\n  toggleTurn() {\n    this.player = this.player === Player.First ? Player.Second : Player.First\n    this.actionCount = 1\n\n    if (this.canPutField !== this.player) {\n      this.canPutField = this.player\n      this.emit(TurnEvent.ToggleField)\n    }\n\n    this.emit(TurnEvent.ToggleTurn)\n  }\n}\n\nclass GameModerator {\n  // state\n  gameState: GameState = GameState.Play\n\n  // Game Object\n  firstField: FirstField\n  secondField: SecondField\n  gameSetScene: GameSetScene\n\n  constructor(\n    firstField: FirstField,\n    secondField: SecondField,\n    gameSetScene: GameSetScene\n  ) {\n    this.firstField = firstField\n    this.secondField = secondField\n    this.gameSetScene = gameSetScene\n  }\n\n  init() {\n    scroller.init()\n    turnModerator.init()\n    this.gameSetScene.init()\n    this.secondField.init()\n    this.firstField.init()\n  }\n\n  gameSet(tokens: PlayerToken[]) {\n    let hue =\n      head(tokens).player === Player.First\n        ? COLOR_FIRST_LASER\n        : COLOR_SECOND_LASER\n\n    let slashAnime = new Anime((frame) => {\n      let strength: number\n      let lineFunc = makeLineFunction(\n        head(tokens).centerX + scroller.x,\n        head(tokens).centerY + scroller.y,\n        tail(tokens).centerX + scroller.x,\n        tail(tokens).centerY + scroller.y\n      )\n\n      if (frame <= 4) {\n        strength = frame / 4\n        const [x1, y1] = lineFunc(0)\n        const [x2, y2] = lineFunc(windowWidth * strength)\n        laserLine(x1, y1, x2, y2, hue)\n      } else if (frame <= 34) {\n        if (frame === 5) sound.play(\"laser\")\n        const [x1, y1] = lineFunc(0)\n        const [x2, y2] = lineFunc(windowWidth)\n        laserLine(x1, y1, x2, y2, hue)\n      } else if (frame <= 84) {\n        if (frame === 38) sound.play(\"gameset\")\n        strength = (frame - 34) / (84 - 34)\n        const [x1, y1] = lineFunc(0)\n        const [x2, y2] = lineFunc(windowWidth)\n        const maxWeight = max([windowWidth, windowHeight]) * 2.5\n        laserLine(x1, y1, x2, y2, hue, maxWeight * strength)\n      } else if (frame <= 94) {\n        const [x1, y1] = lineFunc(0)\n        const [x2, y2] = lineFunc(windowWidth)\n        const maxWeight = max([windowWidth, windowHeight]) * 2.5\n        laserLine(x1, y1, x2, y2, hue, maxWeight)\n      } else {\n        return true\n      }\n    })\n    animeViews.add(slashAnime)\n\n    slashAnime.on(AnimeEvent.Done, () => {\n      this.firstField.enable = false\n      this.secondField.enable = false\n      this.gameSetScene.show(head(tokens).player as Player)\n    })\n\n    let animes = tokens.map((t) => t.blinkAnime)\n    animes.push(slashAnime)\n    Anime.playParallel(animes, COMBO_ANIME_DELAY)\n  }\n}\n\nfunction judgeGameSet(\n  player: Player,\n  column: number,\n  row: number,\n  field: FieldData\n): PlayerToken[] {\n  let lines = field.getComboLines(column, row, GAME_SET_CHAIN_SIZE)\n  for (let tokens of lines) {\n    let result = getComboTokens(player, tokens, GAME_SET_CHAIN_SIZE)\n    if (0 < result.length) {\n      return result\n    }\n  }\n  return []\n}\n\nfunction getCombos(\n  player: Player,\n  column: number,\n  row: number,\n  field: FieldData\n): PlayerToken[][] {\n  // Combos do not occur on enemy fields.\n  if (turnModerator.player !== turnModerator.canPutField) {\n    return []\n  }\n\n  let result: PlayerToken[][] = []\n  let lines = field.getComboLines(column, row, COMBO_SIZE + 1)\n  for (let tokens of lines) {\n    // If a combo has already occurred, it will not be counted.\n    // It exists only at the terminal.\n    let terminal = tokens.slice(0, COMBO_SIZE + 1)\n    if (isCombo(player, terminal, COMBO_SIZE + 1)) {\n      tokens = tokens.slice(COMBO_SIZE)\n    }\n    terminal = tokens.slice(-(COMBO_SIZE + 1))\n    if (isCombo(player, terminal, COMBO_SIZE + 1)) {\n      tokens = tokens.slice(0, -COMBO_SIZE)\n    }\n\n    let comboTokens = getComboTokens(player, tokens, COMBO_SIZE)\n    if (0 < comboTokens.length) {\n      result.push(comboTokens)\n    }\n  }\n\n  return result\n}\n\nfunction getComboTokens(\n  player: Player,\n  tokens: Array<Token | undefined>,\n  size: number\n): PlayerToken[] {\n  let result: PlayerToken[] = []\n\n  for (let token of tokens) {\n    if (token === undefined) {\n      result = []\n      continue\n    }\n\n    if (token.player === player) {\n      result.push(token as PlayerToken)\n    } else {\n      result = []\n    }\n\n    if (size <= result.length) {\n      return result\n    }\n  }\n  return []\n}\n\nfunction isCombo(\n  player: Player,\n  tokens: Array<Token | undefined>,\n  size: number\n): boolean {\n  return 0 < getComboTokens(player, tokens, size).length\n}\n\nconst slashAnimeHandler: AnimeHandler = (frame, params) => {\n  if (frame === 1) {\n    sound.play(\"laser\")\n  }\n\n  let strength: number\n  let lineFunc = makeLineFunction(\n    params.x1 + scroller.x,\n    params.y1 + scroller.y,\n    params.x2 + scroller.x,\n    params.y2 + scroller.y\n  )\n\n  if (frame <= 4) {\n    strength = frame / 4\n    const [x1, y1] = lineFunc(0)\n    const [x2, y2] = lineFunc(windowWidth * strength)\n    laserLine(x1, y1, x2, y2, params.hue)\n  } else if (frame <= 64) {\n    const [x1, y1] = lineFunc(0)\n    const [x2, y2] = lineFunc(windowWidth)\n    laserLine(x1, y1, x2, y2, params.hue)\n  } else if (frame <= 68) {\n    strength = (frame - 64) / (68 - 64)\n    const [x1, y1] = lineFunc(windowWidth * strength)\n    const [x2, y2] = lineFunc(windowWidth)\n    laserLine(x1, y1, x2, y2, params.hue)\n  } else {\n    return true\n  }\n}\n\n// Create a function of a straight line passing through two points.\n// The created function returns [x, y] when passed x.\n// (auxiliary variable)\nfunction makeLineFunction(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number\n): (x: number) => [number, number] {\n  if (x1 === x2) {\n    // When x1 and x2 are the same, they cannot be represented by \"y = ax + b\".\n    return (x: number) => [x1, (windowHeight * x) / windowHeight]\n  }\n\n  return (x: number) => [x, ((y2 - y1) * (x - x1)) / (x2 - x1) + y1]\n}\n\nfunction betweenLine(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  offset: number\n): void {\n  if (x1 === x2) {\n    line(x1 + offset, y1, x2 + offset, y2)\n    line(x1 - offset, y1, x2 - offset, y2)\n  } else {\n    line(x1, y1 + offset, x2, y2 + offset)\n    line(x1, y1 - offset, x2, y2 - offset)\n  }\n}\n\nfunction laserLine(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  hue: number,\n  coreWeight: number | undefined = undefined\n): void {\n  const rates = [5, 2, 6, 6]\n  const totalRate = rates.reduce((value, total) => total + value)\n  const totalWeight =\n    coreWeight === undefined ? TOKEN_SIZE : (coreWeight * totalRate) / rates[0]\n  const weights = rates.map((rate) => (totalWeight * rate) / totalRate / 2)\n\n  let offset = weights[0] / 2\n  stroke(`hsl(${hue}, 100%, 100%)`)\n  strokeWeight(weights[0])\n  betweenLine(x1, y1, x2, y2, offset)\n\n  offset += weights[0] / 2 + weights[1] / 2\n  stroke(`hsl(${hue}, 100%, 50%)`)\n  strokeWeight(weights[1])\n  betweenLine(x1, y1, x2, y2, offset)\n\n  offset += weights[1] / 2 + weights[2] / 2\n  stroke(`hsla(${hue}, 100%, 50%, 0.5)`)\n  strokeWeight(weights[2])\n  betweenLine(x1, y1, x2, y2, offset)\n\n  offset += weights[2] / 2 + weights[3] / 2\n  stroke(`hsla(${hue}, 100%, 50%, 0.2)`)\n  strokeWeight(weights[3])\n  betweenLine(x1, y1, x2, y2, offset)\n}\n\nfunction comboAnimate(tokens: PlayerToken[]): Anime {\n  if (tokens.length < 2) {\n    never(`You need at least two tokens. size: ${tokens.length}`)\n  }\n\n  let animes = tokens.map((t) => t.blinkAnime)\n  let tailTokenAnime = tail(animes)\n\n  let slashAnime = new Anime(slashAnimeHandler, {\n    x1: head(tokens).centerX,\n    y1: head(tokens).centerY,\n    x2: tail(tokens).centerX,\n    y2: tail(tokens).centerY,\n    hue:\n      head(tokens).player === Player.First\n        ? COLOR_FIRST_LASER\n        : COLOR_SECOND_LASER,\n  })\n  animeViews.add(slashAnime)\n\n  animes.push(slashAnime)\n  Anime.playParallel(animes, COMBO_ANIME_DELAY)\n\n  return tailTokenAnime\n}\n\nfunction chainComboAnimate(combos: PlayerToken[][]): void {\n  if (combos.length === 0) {\n    return\n  } else if (combos.length === 1) {\n    comboAnimate(head(combos))\n  } else {\n    let anime = comboAnimate(head(combos))\n    anime.onOnce(AnimeEvent.Done, () => {\n      chainComboAnimate(rest(combos))\n    })\n  }\n}\n\nfunction getTextSize() {\n  return floor(min([windowWidth, windowHeight]) / 5)\n}\n\nfunction eventPropagate(\n  eventName: string,\n  gameObjects: object[]\n): void | boolean {\n  for (let i of gameObjects) {\n    let isPropagate = tryCall(i, eventName)\n    if (isPropagate === false) {\n      return false\n    }\n  }\n}\n\nfunction tryCall(object: Object, method_name: string, ...args: any[]): any {\n  if (object === undefined) {\n    return undefined\n  }\n  if (object[method_name] instanceof Function) {\n    return object[method_name](...args)\n  }\n  return undefined\n}\n\n// function devError(msg: string) {\n//   // @ts-ignore\n//   if (process.env.NODE_ENV === \"production\") {\n//     console.error(msg)\n//   } else {\n//     throw new Error(msg)\n//   }\n// }\n\nfunction range(min: number, max: number, step: number = 1): number[] {\n  let result: number[] = []\n  for (let i = 0; i <= max - min; i += step) {\n    result.push(min + i)\n  }\n  return result\n}\n\nfunction easeInOutQuad(t: number): number {\n  return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t\n}\n\nfunction head<T>(array: Array<T>): T {\n  return array[0]\n}\n\nfunction rest<T>(array: Array<T>): Array<T> {\n  return array.slice(1)\n}\n\nfunction tail<T>(array: Array<T>): T {\n  return array[array.length - 1]\n}\n\nfunction never(message: string = \"It cannot be reached.\"): never {\n  throw new Error(message)\n}\n\nfunction print(...args: any) {\n  console.log(...args)\n}\n\n// ---------------------------------------------------\n// Define the main processing of the game.\n// ---------------------------------------------------\n\nlet views: any[] = []\nlet turnModerator = new TurnModerator()\nlet scroller = new Scroller()\nlet animeViews = new AnimeViews()\nlet delayer = new Delayer()\nlet sound = new Sound()\nlet i18n = new I18n()\n\nwindow.setup = function () {\n  createCanvas(windowWidth, windowHeight)\n  textAlign(CENTER, CENTER)\n  textFont(TEXT_FONT)\n  frameRate(FRAME_RATE)\n\n  let gameSetScene = new GameSetScene()\n\n  let firstField = new FirstField()\n\n  let secondField = new SecondField()\n\n  let gameModerator = new GameModerator(firstField, secondField, gameSetScene)\n  gameModerator.init()\n\n  firstField.on(GameStateEvent.GameSet, (tokens: PlayerToken[]) => {\n    gameModerator.gameSet(tokens)\n  })\n\n  secondField.on(GameStateEvent.GameSet, (tokens: PlayerToken[]) => {\n    gameModerator.gameSet(tokens)\n  })\n\n  gameSetScene.on(GameStateEvent.Init, () => {\n    gameModerator.init()\n  })\n\n  sound.setup()\n\n  views.push(firstField)\n  views.push(secondField)\n  views.push(animeViews)\n  views.push(gameSetScene)\n}\n\nwindow.draw = function () {\n  clear()\n  background(COLOR_BASE)\n  eventPropagate(\"draw\", views)\n  delayer.check()\n}\n\nwindow.mouseClicked = function () {\n  return eventPropagate(\"mouseClicked\", views.reverse())\n}\n\nwindow.touchStarted = function () {\n  scroller.touchStarted()\n}\n\nwindow.touchMoved = function () {\n  scroller.touchMoved()\n  return false\n}\n\nwindow.touchEnded = function () {\n  scroller.touchEnded()\n}\n\nwindow.windowResized = function () {\n  resizeCanvas(windowWidth, windowHeight)\n  return eventPropagate(\"windowResized\", views)\n}\n"],"names":["me","ja","en","zh","you","$4aa43453292a164f3eef341744374d03$var$TOKEN_SIZE","$4aa43453292a164f3eef341744374d03$var$COLOR_MAIN","$4aa43453292a164f3eef341744374d03$var$COLOR_FIRST","$4aa43453292a164f3eef341744374d03$var$COLOR_SECOND","$4aa43453292a164f3eef341744374d03$var$COLOR_FOCUS_FIELD","$4aa43453292a164f3eef341744374d03$var$Player","Player","$4aa43453292a164f3eef341744374d03$var$GameState","GameState","$4aa43453292a164f3eef341744374d03$var$GameStateEvent","GameStateEvent","$4aa43453292a164f3eef341744374d03$var$AnimeEvent","AnimeEvent","$4aa43453292a164f3eef341744374d03$var$TurnEvent","TurnEvent","$4aa43453292a164f3eef341744374d03$var$EventEmitter","listeners","Map","onceListeners","on","eventName","listener","list","this","get","push","set","onOnce","emit","args","delete","$4aa43453292a164f3eef341744374d03$var$Anime","animes","callback","maxCount","length","count","forEach","a","Done","delay","$4aa43453292a164f3eef341744374d03$var$head","play","$4aa43453292a164f3eef341744374d03$var$delayer","playParallel","$4aa43453292a164f3eef341744374d03$var$rest","$4aa43453292a164f3eef341744374d03$var$tail","$4aa43453292a164f3eef341744374d03$var$never","constructor","handler","params","super","init","isPlay","startFrameCount","frameCount","Play","abort","Abort","draw","$4aa43453292a164f3eef341744374d03$var$AbstractToken","x","$4aa43453292a164f3eef341744374d03$var$scroller","y","baseX","baseY","$4aa43453292a164f3eef341744374d03$var$PlayerToken","blinkAnime","frame","$4aa43453292a164f3eef341744374d03$var$sound","stroke","strokeWeight","fill","color","rect","stop","$4aa43453292a164f3eef341744374d03$var$FirstToken","player","First","$4aa43453292a164f3eef341744374d03$var$SecondToken","Second","$4aa43453292a164f3eef341744374d03$var$GuideToken","undefined","PHASE","anime","c","$4aa43453292a164f3eef341744374d03$var$turnModerator","max","strength","setAlpha","min","noStroke","$4aa43453292a164f3eef341744374d03$var$FieldData","data","token","column","row","add","v","getComboLines","size","lines","tokenLine","$4aa43453292a164f3eef341744374d03$var$range","map","offset","$4aa43453292a164f3eef341744374d03$var$AbstractField","windowResized","fieldData","canPutField","tokens","field","result","$4aa43453292a164f3eef341744374d03$var$getComboTokens","$4aa43453292a164f3eef341744374d03$var$judgeGameSet","GameSet","addCandidates","nextFrame","combos","$4aa43453292a164f3eef341744374d03$var$COMBO_SIZE","terminal","slice","$4aa43453292a164f3eef341744374d03$var$isCombo","comboTokens","$4aa43453292a164f3eef341744374d03$var$getCombos","$4aa43453292a164f3eef341744374d03$var$chainComboAnimate","addComboCount","action","guideAnimePlay","enable","mouseClicked","toCell","mouseX","mouseY","$4aa43453292a164f3eef341744374d03$var$makeTokenTurn","$4aa43453292a164f3eef341744374d03$var$FirstField","floor","isCanPutField","line","windowWidth","$4aa43453292a164f3eef341744374d03$var$MARGIN_FIRLD","windowHeight","$4aa43453292a164f3eef341744374d03$var$SecondField","$4aa43453292a164f3eef341744374d03$var$GameSetScene","showAnime","coreDraw","hideAnime","t","show","hide","Init","alphaRate","background","textSize","text","$4aa43453292a164f3eef341744374d03$var$GameModerator","gameState","firstField","secondField","gameSetScene","gameSet","hue","slashAnime","lineFunc","$4aa43453292a164f3eef341744374d03$var$makeLineFunction","centerX","centerY","x1","y1","x2","y2","$4aa43453292a164f3eef341744374d03$var$laserLine","maxWeight","$4aa43453292a164f3eef341744374d03$var$animeViews","$4aa43453292a164f3eef341744374d03$var$slashAnimeHandler","$4aa43453292a164f3eef341744374d03$var$betweenLine","coreWeight","rates","totalRate","reduce","value","total","totalWeight","weights","rate","$4aa43453292a164f3eef341744374d03$var$comboAnimate","tailTokenAnime","$4aa43453292a164f3eef341744374d03$var$eventPropagate","gameObjects","i","$4aa43453292a164f3eef341744374d03$var$tryCall","object","method_name","Function","step","array","message","Error","$4aa43453292a164f3eef341744374d03$var$views","actionCount","toggleTurn","toggleField","ToggleField","ToggleTurn","startX","startY","oldX","oldY","touchStarted","touchMoved","cursor","touchEnded","Set","callbacks","check","setup","audioElements","setupAudioElement","laser","gameset","blink","name","readyState","HTMLMediaElement","HAVE_ENOUGH_DATA","currentTime","pause","e","document","getElementById","HTMLAudioElement","$4aa43453292a164f3eef341744374d03$var$i18n","i18nText","setCountry","country","window","navigator","language","keyword","countries","$4aa43453292a164f3eef341744374d03$var$DEFAULT_COUNTRY","createCanvas","textAlign","CENTER","textFont","frameRate","gameModerator","clear","reverse","resizeCanvas"],"version":3,"file":"index.20c2c2ca.js.map"}